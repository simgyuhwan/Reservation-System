# 1. 사가 패턴

먼저 트랜잭션이란, 데이터베이스를 변경하는 하나의 작업 단위이다. 모놀로틱 환경에서는 하나의 DB에서 이루어지고 ACID를 지원하기 때문에 트랜잭션 관리가 비교적 쉽다.

하지만 MSA 환경에서는 각각의 도메인마다 DB를 관리하기 때문에 각 DB마다의 트랜잭션을 관리해야 한다. 이를 분산 트랜잭션이라 한다. **분산된 트랜잭션을 관리하기 위한 방법으로는 사가패턴**이 있다. 사가 패턴이란, 순차적으로 실행되는 로컬 트랜잭션을 관리하기 위한 패턴이며 각 서비스는 이벤트를 통한 비동기 방식으로 전달한다.

이 사가 패턴에도 두 가지 방식이 존재한다.

1. **Choregraphy 방식**
2. \***\*Orchestration 방식\*\***

이 두 가지가 있는데. 이 글은 Choregraphy 방식의 개념을 보고 상상하여 구현하고 적용하면서 느낀점을 적어보려고 한다.

## 1) ACID

트랜잭션은 **ACID(원자성, 일관성, 격리성, 영속성)을 보장**하는데. 사가 패턴은 격리성, 일관성을 보장하기 어렵다.

격리성이랑 하나의 트랜잭션이 다른 트랜잭션에 영향을 미치지 말아야하는데. 분산된 트랜잭션을 관리하는 환경에서는 쉽지 않다. 예를 들어보자. 상품의 상태를 변경하는 요청이 왔을 때, 재고 서비스에 이 변경된 요청을 전달한다고 가정해보자.

상품의 상태가 변경되어 DB에 커밋한 뒤 이벤트를 발행했을 때, 재고 서비스에 이벤트가 전달되고 전달된 이벤트에 대한 처리를 진행할 것이다. 재고서비스에서는 재고에 대한 개수의 변경이나 이름의 변경이 일어날 수 있다. 그런데 재고 서비스에서 장애가 발생하여 보상 트랜잭션을 진행하고 이전 상태로 롤백한다고 했을 때. 상품의 상태를 다시 이전 상태로 롤백해야 한다. 하지만 롤백 이전에 사용자가 상품 상태를 조회하면 롤백 전의 상태를 조회하게 된다. 이와 같이 **격리성의 부족으로 인해 일관성을 보장하지 못하게 된다.**

이를 위해 **최종 일관성**을 보장하는 방식으로 처리했다. 최종 일관성이란, 데이터의 일관성이 즉시 보장되지 않고, 어느 정도의 지연 시간이나 오차가 발생할 수 있지만, 결국에는 일관된 상태로 수렴한다.

## 2) Choregraphy

choregraphy 방식이란, 각각의 서비스들이 서로 이벤트를 구독하고 발행하여 트랜잭션을 관리하는 방식이다. 예를 들어, 아래와 같은 흐름이 될 수 있다.

**주문 요청 → 주문 서비스 → 재고 서비스 → 결제 서비스**

주문 서비스에서 트랜잭션을 커밋하고 완료하면 재고 서비스에 전달하고 재고 서비스에서 트랜잭션이 완료되면 결제 서비스로 전달한다.

장애가 났을 때는 반대로 롤백 이벤트를 진행한다.

# 2. Choregraphy 적용해보기

Choregraphy 방식의 예시 코드를 찾기는 어려웠지만 개념에 대해서는 많이 읽어볼 수 있었다. 개념을 읽고 공연 서비스에서 처리하는 공연 등록, 공연 수정에 대해서 Choregraphy 방식으로 구현해봤다.

**공연 서비스는 등록과 수정에 대해 예약 서비스에 정보를 전달**한다. 공연에 대한 정보를 저장하면 예약 서비스는 예약 가능한 공연 정보와 좌석 정보를 저장한다.

## 1) 공연 등록

공연 서비스의 이벤트에 대한 처리를 이벤트 모듈로 분리했다. 이벤트 모듈은 내부 이벤트와 외부 이벤트로 분리하였고 내부 이벤트는 이벤트의 기록과 처리를 담당한다. 외부 이벤트는 외부로 이벤트 발행과 외부에서 온 이벤트 처리를 담당한다. 먼저 공연 등록을 구현하면서 고민했던 부분은 다음과 같다.

- **이벤트로 전달할 값**
- **보상 트랜잭션**
- **멱등성**

### 이벤트로 전달할 값

공연 서비스에서 공연 등록 신청이 되면 예약 서비스로 이벤트가 발행한다. 예약 서비스에서는 공연 정보를 가지고 공연 가능한 예약 정보와 좌석 정보를 저장한다.

처음에는 단순히 이벤트에 공연 정보를 모두 담아서 전달했다. 처리하는 데는 문제가 없었고 문제 없이 저장이 됐었다. 하지만 데이터의 변경이 잦았고 그때마다 이벤트에 관여되는 모든 곳을 수정하는 것이 불가피했다.

너무 비효율적인 설계인 듯 싶어 대안이 필요했고 구글링의 결과, [우아한 형제들의 블로그](https://techblog.woowahan.com/7835/)를 읽고 바로 적용해보기로 했다. **zero payload** 방식으로, 이벤트 처리를 위한 페이로드에 필요한 식별 값만 포함시킨다.

공연 서비스에서는 등록한 **공연 ID** 값을 이벤트 페이로드에 담아 예약 서비스에 전달한다. 예약 서비스는 공연 ID 값을 사용하여 API 요청을 하고 필요한 값을 조회한다. API에 대한 추가 구현이 필요했지만 이 방법을 통해 코드의 변경점을 최소화 할 수 있었다.

```java
public class PerformanceCreatedPayload implements Payload {
	private String id;
	private Long performanceId;
	private Long memberId;
}
```

### 보상 트랜잭션

공연 서비스에서 실패한다면 로컬 DB에 관한 트랜잭션 관리가 되기 때문에 간단하게 롤백할 수 있지만 이미 커밋후 이벤트를 발행하고 예약 서비스에서 처리할 때의 장애 시, 보상 트랜잭션 처리에 관해서도 고민을 많이 했다.

예를 들어, 공연을 등록하고 성공했지만 예약 서비스에서 처리가 안끝났을 때, 공연 서비스에 등록한 공연 정보를 조회하면 조회가 될 텐데. 이를 어떻게 하는게 좋을까? 상태 값을 추가해서 등록 대기로 처리해야 하나?

등록대기면 예약 서비스에서 등록된 공연을 조회해야 하는데. 기존 API로는 조회가 안되는데. 어떡해야 하지? 실패하면 삭제 처리해야 하나? 남겨야 하나?

결과적으로 공연 Entity에 상태 값을 추가했다. 등록 시, 공연 정보는 Pending 상태로 두엇다. 사용자는 따로 추가한 api를 통해서 공연 등록 상태를 조회할 수 있게 했다. 예약 서비스는 pending 상태인 공연 정보를 조회하는 api를 통해서 예약 정보와 좌석 정보를 저장하게 했다.

```java
public enum RegisterStatusType {
    PENDING("등록 요청 대기중"),
    COMPLETED("등록 완료"),
    FAILED("등록 실패");
		...
}
```

일반적인 공연 조회에서는 상태가 **COMPLETE** 인 공연만 조회하도록 변경했으며 예약 서비스에서 실패시, FAILED 상태로 변경한다. 사용자는 **FAILED** 된 공연을 조회하면 재등록 요청 메시지를 받게 된다.

이 밖에도 이벤트 발행과 처리는 모두 저장하여 이벤트 처리 순서를 확인할 수 있도록 처리했다.

### 멱등성

동일한 요청에는 동일한 응답 값을 보장하는 멱등성을 위해 이벤트 응답에 대한 저장과 캐시를 사용했다. 만약 동일한 요청이 여러 번 온다면 캐시 값을 조회하여 반환하게 되고 캐시에 없다면 DB를 조회해서 반환해준다.

```java
public EventResult savePerformanceInfo(DefaultEvent<PerformanceEventPayload> event) {
		String eventId = event.getId();
		Payload payload = event.getPayload();

		**// 처리된 이벤트라면 이전 처리 결과 반환**
		if(isProcessedEvent(eventId)) {
			return getProcessedEventResult(eventId);
		}
		**// 이벤트 처리**
		return processCreatedEvent(eventId, payload);
	}
```

## 2) 공연 수정

등록의 경우는 단순히 대기 상태로 바꾸는 것으로 손쉽게 해결이 가능했다. 하지만 데이터의 수정은 쉽지 않았다. 이유는 공연 정보가 수정되고 커밋이 되었을 때, 예약 서비스에서 실패한다면 보상 트랜잭션을 진행해야 하는데. 바뀌기 전 데이터에 대한 보관이 문제였다. 이전 데이터에 대한 정보가 있어야 롤백이 가능한데. 이 정보를 어디에 저장해야 하지? 고민했고 세 가지 정도를 떠올렸다.

### 임시 저장소

동일한 DB나 NoSQL에 이러한 정보를 따로 저장하는 방법이었다. 캐시를 사용하자니 유실됐을 때의 손실이 크다. 동일한 DB에 저장하는 방법은 따로 테이블을 만드는 건데. 관련 테이블을 그대로 하나 만들어야 하는 고민이 있었고 NoSQL을 이용할까 했으나 그러면 모든 서비스에서 사용하게 해야 하나? 아니면 각 서비스에 하나 씩 둬야 하는걸까? 그러면 각 서비스 당 두 개의 DB를 사용하게 될텐데. 너무 과하지 않을까 싶었다.

### 버전

**공연 Entity의 식별 값과 버전을 복합키**로 사용하는 방법이다. 공연에 대한 수정 작업이 있을 때 버전을 올려주고 조회 시, 최신 버전만 조회한다. 만약 롤백해야 한다면 이전 버전으로 돌려주기만 하면 된다. 세 가지 방법 중에 가장 괜찮아 보였으나 바로 이전의 너무 많은 변경의 작업으로 지쳤던 터라 다음 방법을 사용하기로 했다.

### 최종 일관성

스케줄러를 통한 이벤트 재발행을 통해서 최종 일관성을 보장한다. 이벤트 실패시 RETRY 상태로 변경하고 스케줄러를 통해 이벤트 타입과 상태를 통해 재발행해야 할 이벤트를 조회하여 다시 발행한다.

그 잠깐 사이의 정보의 오류는 일단 감수하기로 했다. 스케줄러로 이벤트를 재발행하기 전에 모니터링을 통해 장애를 확인하고 처리해야 하기 때문에 장애에 대한 저장 처리를 추가했다. 이 부분은 간단하게만 작성했다.

```java
/**
 * 공연 수정 Retry 이벤트 재발행
 */
@Scheduled(cron = "0 0/10 * * * *")
public void rePublishUpdateEvent(){
	performanceEventService.rePublishPerformanceUpdateEvent();
}
```

이 부분의 아쉬웠던 점은 스케줄러를 모듈로 분리하고 처리하고 싶었으나 도메인에서 이벤트를 관리하도록 해버려서 어려웠다. 조금 더 고민해야할 부분이다.

# 느낀점

해보면 할 수 있겠지라고 단순하게 생각했던 분산 트랜잭션에 대해 생각해야 할 것이 너무나 많다는 것을 느꼈다. 개념을 읽고 필요한 부분의 해결을 찾아보고 상상하며 구현했지만, 실제로 다른 방법이 있나 찾아보니 다양한 방법을 찾을 수 있었다. 그리고 다시금 느끼는 것이 경험을 통해 어느 정도의 설계를 하고 시작하는게 좋겠구나 싶다. 이번 프로젝트에서는 일단 시작하고 찾아가며 구현하다보니 너무나 잦은 변경이 이루어졌다. 물론 덕분에 변경을 최소화하기 위한 고민을 할 수 있어서 도움이 됐다.

### 참고

[https://learn.microsoft.com/ko-kr/azure/architecture/reference-architectures/saga/saga](https://learn.microsoft.com/ko-kr/azure/architecture/reference-architectures/saga/saga)

[https://azderica.github.io/01-architecture-msa/](https://azderica.github.io/01-architecture-msa/)
